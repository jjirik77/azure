<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Image Processing Explorer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* gray-100 */
        }
        .concept-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 1.5rem;
            margin-bottom: 2rem;
            overflow: hidden;
        }
        .pixel-grid {
            display: grid;
            gap: 2px;
            border: 1px solid #d1d5db; /* gray-300 */
            width: 156px;
            height: 156px;
        }
        .pixel {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            color: white;
            text-shadow: 1px 1px 2px black;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s ease-in-out;
        }
        .pixel:hover {
            transform: scale(1.1);
            z-index: 10;
        }
        .pixel.highlight {
            outline: 2px solid #3b82f6; /* blue-500 */
            outline-offset: 1px;
            z-index: 20;
        }
        .kernel-highlight {
            outline: 2px solid #ef4444; /* red-500 */
            outline-offset: 1px;
            z-index: 20;
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.7);
        }
        .rendered-image {
            width: 154px;
            height: 154px;
            image-rendering: pixelated;
            border: 2px solid #e5e7eb; /* gray-200 */
        }
        .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8rem;
            white-space: pre;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d1d5db;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
        }
        #r-slider::-webkit-slider-thumb { background: #ef4444; }
        #g-slider::-webkit-slider-thumb { background: #22c55e; }
        #b-slider::-webkit-slider-thumb { background: #3b82f6; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-5xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800">The Interactive World of Image Processing</h1>
            <p class="mt-2 text-lg text-gray-600">Explore how computers "see" and manipulate images.</p>
        </header>

        <!-- Grayscale Image Section -->
        <div class="concept-card" id="grayscale-section">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">1. Images as Grayscale Pixels</h2>
            <p class="text-gray-600 mb-6">A computer sees a grayscale image as a 2D grid (or array) of numbers. Each number represents a pixel's brightness, typically from 0 (black) to 255 (white). Click on the pixels in the grid to change their values and see the image update in real time.</p>
            <div class="flex flex-col md:flex-row gap-8 items-center justify-center">
                <div>
                    <h3 class="font-semibold text-center mb-2">Interactive Pixel Grid</h3>
                    <div id="grayscale-grid" class="pixel-grid mx-auto"></div>
                </div>
                <div>
                    <h3 class="font-semibold text-center mb-2">Rendered Image</h3>
                    <canvas id="grayscale-canvas" class="rendered-image mx-auto"></canvas>
                </div>
                <div>
                    <h3 class="font-semibold text-center mb-2">Pixel Value Array</h3>
                    <div id="grayscale-array" class="code-block text-center"></div>
                </div>
            </div>
        </div>

        <!-- RGB Image Section -->
        <div class="concept-card" id="rgb-section">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">2. Building Color with RGB Channels</h2>
            <p class="text-gray-600 mb-6">Color images are usually made of three layers, or "channels": Red, Green, and Blue (RGB). By combining different values (0-255) for each channel, we can create any color. Use the sliders to select a color, then "paint" on the main grid by clicking pixels.</p>
            
            <div class="flex flex-col md:flex-row gap-4 items-center justify-center mb-6">
                 <!-- Color Controls -->
                <div class="w-full md:w-1/3 p-4 border rounded-lg">
                    <h3 class="font-semibold mb-3 text-center">Color Painter</h3>
                    <div class="slider-container">
                        <span class="font-medium text-red-500">R</span>
                        <input type="range" min="0" max="255" value="255" class="slider" id="r-slider">
                    </div>
                    <div class="slider-container mt-2">
                        <span class="font-medium text-green-500">G</span>
                        <input type="range" min="0" max="255" value="255" class="slider" id="g-slider">
                    </div>
                    <div class="slider-container mt-2">
                        <span class="font-medium text-blue-500">B</span>
                        <input type="range" min="0" max="255" value="0" class="slider" id="b-slider">
                    </div>
                    <div class="flex items-center justify-center gap-4 mt-4">
                        <span>Selected Color:</span>
                        <div id="color-preview" class="w-10 h-10 rounded-full border"></div>
                    </div>
                </div>
                <!-- Combined Image -->
                <div class="text-center">
                    <h3 class="font-semibold mb-2">Combined Color Image</h3>
                    <div id="rgb-canvas-wrapper" class="relative">
                        <canvas id="rgb-canvas" class="rendered-image mx-auto"></canvas>
                    </div>
                </div>
                <!-- Channel Previews -->
                <div class="flex gap-2 justify-center">
                    <div class="text-center">
                        <h4 class="text-sm font-medium text-red-500">Red</h4>
                        <canvas id="r-canvas" class="w-16 h-16 md:w-20 md:h-20 rendered-image"></canvas>
                    </div>
                    <div class="text-center">
                        <h4 class="text-sm font-medium text-green-500">Green</h4>
                        <canvas id="g-canvas" class="w-16 h-16 md:w-20 md:h-20 rendered-image"></canvas>
                    </div>
                    <div class="text-center">
                        <h4 class="text-sm font-medium text-blue-500">Blue</h4>
                        <canvas id="b-canvas" class="w-16 h-16 md:w-20 md:h-20 rendered-image"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Convolutional Filter Section -->
        <div class="concept-card" id="filter-section">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">3. Image Processing with Filters (Convolution)</h2>
            <p class="text-gray-600 mb-6">A common technique is to apply a filter, or <span class="font-semibold">kernel</span>, to an image. The kernel is a small matrix of numbers. It slides over every part of the image, calculating a new pixel value based on its neighbors. This process is called <span class="font-semibold">convolution</span>. Press "Play" to see an edge-detection filter in action!</p>
            
            <div class="flex justify-center items-center gap-4 mb-6">
                <button id="play-pause-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">Play</button>
                <button id="reset-btn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded">Reset</button>
            </div>

            <div class="flex flex-col lg:flex-row gap-8 items-start justify-center">
                <!-- Original Image -->
                <div class="text-center flex-shrink-0">
                    <h3 class="font-semibold mb-2">Original Image</h3>
                    <div id="conv-original-grid" class="pixel-grid mx-auto"></div>
                </div>

                <!-- Kernel and Calculation -->
                <div class="text-center flex-shrink-0">
                    <h3 class="font-semibold mb-2">Filter Kernel</h3>
                    <div class="code-block" style="width: 156px; text-align: center; margin: 0 auto;">-1  -1  -1<br>-1   8  -1<br>-1  -1  -1</div>
                    <div id="calculation-display" class="mt-4 p-2 border rounded-lg bg-gray-50 h-32 text-xs text-left overflow-auto">
                        Calculation appears here...
                    </div>
                </div>

                <!-- Filtered Image -->
                <div class="text-center flex-shrink-0">
                    <h3 class="font-semibold mb-2">Filtered Image</h3>
                    <div id="conv-filtered-grid" class="pixel-grid mx-auto bg-gray-200"></div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- Constants and State ---
        const GRID_SIZE = 7;
        const PIXEL_STATES = [0, 128, 255];
        let grayscaleData = createInitialGrayscaleData();
        let rgbData = createInitialRgbData();
        let rgbClickableGrid; // Define globally to be accessible by update functions
        
        // Convolution state
        const convOriginalData = createInitialGrayscaleData();
        const kernel = [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]];
        let convFilteredData = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
        let convAnimation;
        let convState = { x: 0, y: 0, isPlaying: false };

        // --- Element References ---
        const grayscaleGrid = document.getElementById('grayscale-grid');
        const grayscaleCanvas = document.getElementById('grayscale-canvas');
        const grayscaleArrayDiv = document.getElementById('grayscale-array');
        
        const rSlider = document.getElementById('r-slider');
        const gSlider = document.getElementById('g-slider');
        const bSlider = document.getElementById('b-slider');
        const colorPreview = document.getElementById('color-preview');
        const rgbCanvasWrapper = document.getElementById('rgb-canvas-wrapper');
        const rgbCanvas = document.getElementById('rgb-canvas');
        const rCanvas = document.getElementById('r-canvas');
        const gCanvas = document.getElementById('g-canvas');
        const bCanvas = document.getElementById('b-canvas');

        const convOriginalGrid = document.getElementById('conv-original-grid');
        const convFilteredGrid = document.getElementById('conv-filtered-grid');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const calculationDisplay = document.getElementById('calculation-display');

        // --- Initial Data Factories ---
        function createInitialGrayscaleData() {
            const data = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            for (let i = 2; i <= 4; i++) {
                for (let j = 2; j <= 4; j++) {
                    data[i][j] = 255;
                }
            }
            return data;
        }

        function createInitialRgbData() {
            const data = Array(GRID_SIZE).fill(0).map(() => 
                Array(GRID_SIZE).fill(0).map(() => ({ r: 20, g: 20, b: 20 }))
            );
            return data;
        }

        // --- Generic Drawing and Grid Functions ---
        function drawPixelGrid(container, data, clickHandler, isRgb = false) {
            container.innerHTML = '';
            container.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const pixel = document.createElement('div');
                    pixel.classList.add('pixel');
                    pixel.dataset.row = i;
                    pixel.dataset.col = j;
                    const value = data[i][j];
                    if (isRgb) {
                        pixel.style.backgroundColor = `rgb(${value.r}, ${value.g}, ${value.b})`;
                    } else {
                        pixel.style.backgroundColor = `rgb(${value}, ${value}, ${value})`;
                        pixel.textContent = value;
                    }
                    if (clickHandler) {
                        pixel.addEventListener('click', clickHandler);
                    }
                    container.appendChild(pixel);
                }
            }
        }

        function drawCanvas(canvas, data, isRgb = false, channel = null) {
            // FIX: Explicitly set the canvas drawing buffer size to match our data grid.
            // This ensures the 7x7 pixel data correctly maps to the 7x7 canvas drawing area.
            canvas.width = GRID_SIZE;
            canvas.height = GRID_SIZE;

            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(GRID_SIZE, GRID_SIZE);
            for (let i = 0; i < data.length; i++) {
                for (let j = 0; j < data[i].length; j++) {
                    const index = (i * GRID_SIZE + j) * 4;
                    const value = data[i][j];
                    if (isRgb) {
                        if (channel === 'r') {
                            imageData.data[index] = value.r;
                            imageData.data[index + 3] = 255;
                        } else if (channel === 'g') {
                            imageData.data[index + 1] = value.g;
                            imageData.data[index + 3] = 255;
                        } else if (channel === 'b') {
                            imageData.data[index + 2] = value.b;
                            imageData.data[index + 3] = 255;
                        } else {
                            imageData.data[index] = value.r;
                            imageData.data[index + 1] = value.g;
                            imageData.data[index + 2] = value.b;
                            imageData.data[index + 3] = 255;
                        }
                    } else {
                        imageData.data[index] = value;
                        imageData.data[index + 1] = value;
                        imageData.data[index + 2] = value;
                        imageData.data[index + 3] = 255;
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // --- Grayscale Section Logic ---
        function handleGrayscaleClick(e) {
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            const currentValue = grayscaleData[row][col];
            const currentIndex = PIXEL_STATES.indexOf(currentValue);
            const nextIndex = (currentIndex + 1) % PIXEL_STATES.length;
            grayscaleData[row][col] = PIXEL_STATES[nextIndex];
            updateGrayscaleVisualization();
        }

        function updateGrayscaleArray() {
            grayscaleArrayDiv.textContent = grayscaleData.map(row => 
                row.map(val => val.toString().padStart(3, ' ')).join(' ')
            ).join('\n');
        }

        function updateGrayscaleVisualization() {
            drawPixelGrid(grayscaleGrid, grayscaleData, handleGrayscaleClick);
            drawCanvas(grayscaleCanvas, grayscaleData);
            updateGrayscaleArray();
        }

        // --- RGB Section Logic ---
        function handleRgbClick(e) {
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            rgbData[row][col] = {
                r: parseInt(rSlider.value),
                g: parseInt(gSlider.value),
                b: parseInt(bSlider.value)
            };
            updateRgbVisualization();
        }
        
        function updateColorPreview() {
            const r = rSlider.value;
            const g = gSlider.value;
            const b = bSlider.value;
            colorPreview.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
        }

        function updateRgbVisualization() {
            drawPixelGrid(rgbClickableGrid, rgbData, handleRgbClick, true);
            drawCanvas(rgbCanvas, rgbData, true);
            drawCanvas(rCanvas, rgbData, true, 'r');
            drawCanvas(gCanvas, rgbData, true, 'g');
            drawCanvas(bCanvas, rgbData, true, 'b');
        }

        // --- Convolution Section Logic ---
        function resetConvolution() {
            clearInterval(convAnimation);
            convState = { x: 0, y: 0, isPlaying: false };
            playPauseBtn.textContent = 'Play';
            convFilteredData = Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
            drawPixelGrid(convOriginalGrid, convOriginalData, null, false);
            drawPixelGrid(convFilteredGrid, convFilteredData, null, false);
            calculationDisplay.innerHTML = 'Calculation appears here...';
        }
        
        function playPauseConvolution() {
            convState.isPlaying = !convState.isPlaying;
            if (convState.isPlaying) {
                playPauseBtn.textContent = 'Pause';
                convAnimation = setInterval(stepConvolution, 200);
            } else {
                playPauseBtn.textContent = 'Play';
                clearInterval(convAnimation);
            }
        }

        function stepConvolution() {
            if (convState.y > GRID_SIZE - 3) {
                playPauseConvolution();
                highlightAll(convOriginalGrid, false);
                return;
            }

            let sum = 0;
            let calcString = '<p>Weighted Sum:</p>';
            highlightAll(convOriginalGrid, false); 

            for (let i = 0; i < 3; i++) {
                let rowString = '';
                for (let j = 0; j < 3; j++) {
                    const imgY = convState.y + i;
                    const imgX = convState.x + j;
                    const pixelVal = convOriginalData[imgY][imgX];
                    const kernelVal = kernel[i][j];
                    sum += pixelVal * kernelVal;
                    
                    const pixelEl = convOriginalGrid.querySelector(`[data-row='${imgY}'][data-col='${imgX}']`);
                    if(pixelEl) pixelEl.classList.add('kernel-highlight');

                    rowString += `(${pixelVal}×${kernelVal}) + `;
                }
                calcString += `<span class="text-xs">${rowString.slice(0,-2)}</span><br>`;
            }
            
            let finalValue = Math.max(0, Math.min(255, sum));
            convFilteredData[convState.y + 1][convState.x + 1] = finalValue;
            
            calcString += `<hr class="my-1"><p>Result: ${sum} → ${finalValue}</p>`;
            calculationDisplay.innerHTML = calcString;
            
            const filteredPixel = convFilteredGrid.querySelector(`[data-row='${convState.y + 1}'][data-col='${convState.x + 1}']`);
            if(filteredPixel) {
                filteredPixel.style.backgroundColor = `rgb(${finalValue}, ${finalValue}, ${finalValue})`;
                filteredPixel.textContent = finalValue;
                filteredPixel.classList.add('highlight');
                setTimeout(() => filteredPixel.classList.remove('highlight'), 1000);
            }

            convState.x++;
            if (convState.x > GRID_SIZE - 3) {
                convState.x = 0;
                convState.y++;
            }
        }
        
        function highlightAll(grid, shouldHighlight) {
             grid.querySelectorAll('.pixel').forEach(p => p.classList.remove('kernel-highlight'));
        }

        // --- Initialization ---
        function init() {
            // Grayscale
            updateGrayscaleVisualization();

            // RGB
            rSlider.addEventListener('input', updateColorPreview);
            gSlider.addEventListener('input', updateColorPreview);
            bSlider.addEventListener('input', updateColorPreview);
            
            rgbClickableGrid = document.createElement('div');
            rgbClickableGrid.classList.add('pixel-grid');
            rgbClickableGrid.style.position = 'absolute';
            rgbClickableGrid.style.top = '0';
            rgbClickableGrid.style.left = '0';
            rgbCanvasWrapper.appendChild(rgbClickableGrid);
            
            updateColorPreview();
            updateRgbVisualization();

            // Convolution
            playPauseBtn.addEventListener('click', playPauseConvolution);
            resetBtn.addEventListener('click', resetConvolution);
            resetConvolution();
        }

        window.addEventListener('load', init);

    </script>
</body>
</html>
